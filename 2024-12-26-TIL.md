# Git TIL 07 <br><br>

>이번 주에 배워야할 라이브러리 학습 내용 <br>


##### - NumPy (수치 계산) 
##### - Pandas (데이터 처리)
##### - Matplotlib/Seaborn (데이터 시각화)
<br><br>

#### 1.numpy에 대해

```
# 1차원 배열 만들기
arr1 = np.array([1, 2, 3, 4, 5])
print("1차원 배열:", arr1)

# 배열의 기본 속성 확인
print("\n배열의 차원:", arr1.ndim)  # 차원
print("배열의 형태:", arr1.shape)    # 형태(shape)
print("배열의 크기:", arr1.size)     # 원소의 개수
```
```
1차원 배열: [1 2 3 4 5]

배열의 차원: 1
배열의 형태: (5,)
배열의 크기: 5
```
- ndim: 배열의 차원 수
- shape: 각 차원의 크기
- size: 전체 원소의 개수

1. 1차원 배열: [1 2 3 4 5]
- 1차원 배열이 생성됨
- 5개의 원소를 가진 배열
2. 배열의 차원: 1
- ndim = 1은 1차원 배열임을 의미
- 한 줄로 된 배열
3. 배열의 형태: (5,)
- shape = (5,)는 길이가 5인 1차원 배열
- 쉼표는 1차원을 나타냄
4. 배열의 크기: 5
- size = 5는 총 5개의 원소가 있다는 의미
```
# 2차원 배열 만들기
arr2 = np.array([[1, 2, 3],
                 [4, 5, 6]])
print("2차원 배열:\n", arr2)
print("\n배열의 차원:", arr2.ndim)
print("배열의 형태:", arr2.shape)    # (행, 열)
print("배열의 크기:", arr2.size)     # 전체 원소 개수
```
```
2차원 배열:
 [[1 2 3]
  [4 5 6]]

배열의 차원: 2
배열의 형태: (2, 3)
배열의 크기: 6
```
numpy 장점:
1. 계산이 더 빠름
2. 코드가 더 간단함
3. 메모리 사용이 효율적

```
# 다양한 데이터 타입의 배열 만들기
arr1 = np.array([1.0, 2.0, 3.0])  # 실수형
arr2 = np.array([1, 2, 3], dtype=float)  # 타입 지정
arr3 = np.array(['a', 'b', 'c'])  # 문자열

print("실수형 배열:", arr1.dtype)
print("타입 지정 배열:", arr2.dtype)
print("문자열 배열:", arr3.dtype)
```
```
실수형 배열: float64
타입 지정 배열: float64
문자열 배열: <U1
```
1. float64:
- 64비트 실수형(소수점이 있는 숫자)
- 예: 1.0, 2.0, 3.14 등
- 매우 정밀한 소수점 계산 가능
2. <U1:
- U는 Unicode 문자열을 의미
- 1은 각 문자의 길이
- 문자열 데이터를 저장할 때 사용
<br>

##### NumPy의 주요 데이터 타입들:
```
# 다양한 데이터 타입 예시
arr1 = np.array([1, 2, 3])                    # int64
arr2 = np.array([1.0, 2.0, 3.0])             # float64
arr3 = np.array([True, False, True])          # bool 
arr4 = np.array(['apple', 'banana', 'cherry']) # <U6

```

이러한 데이터 타입을 이해하는 것이 중요한 이유:
- 메모리 사용량에 영향
- 계산 속도에 영향
- 데이터 정확도에 영향
<br>

```
import numpy as np

# 기본 배열 생성
arr = np.array([1, 2, 3, 4, 5])
print("기본 배열:", arr)

# 1. 사칙연산
print("\n배열 + 2:", arr + 2)  # 모든 원소에 2를 더함
print("배열 * 3:", arr * 3)    # 모든 원소에 3을 곱함
print("배열 / 2:", arr / 2)    # 모든 원소를 2로 나눔

# 2. 배열끼리의 연산
arr2 = np.array([10, 20, 30, 40, 50])
print("\n배열 + 배열:", arr + arr2)  # 같은 위치의 원소끼리 더함
print("배열 * 배열:", arr * arr2)    # 같은 위치의 원소끼리 곱함
```
```
기본 배열: [1 2 3 4 5]

배열 + 2: [3 4 5 6 7]
배열 * 3: [ 3  6  9 12 15]
배열 / 2: [0.5 1.  1.5 2.  2.5]

배열 + 배열: [11 22 33 44 55]
배열 * 배열: [ 10  40  90 160 250]
```

1.**스칼라 연산** (배열과 단일 숫자의 연산):
```
   arr + 2  # [1+2, 2+2, 3+2, 4+2, 5+2]
   arr * 3  # [1*3, 2*3, 3*3, 4*3, 5*3]
   arr / 2  # [1/2, 2/2, 3/2, 4/2, 5/2]
```
- 배열의 각 원소에 동일한 연산이 적용됨

2. **배열 간 연산** (같은 크기의 배열끼리 연산):
```
   arr + arr2  # [1+10, 2+20, 3+30, 4+40, 5+50]
   arr * arr2  # [1*10, 2*20, 3*30, 4*40, 5*50]
```
- 같은 위치의 원소끼리 연산이 이루어짐

<br>

##### 이것이 NumPy의 큰 장점입니다:
- 반복문 없이 배열 전체 연산 가능
- 코드가 간단하고 직관적
- 실행 속도가 매우 빠름

<br><br>

#### 2. 통계 함수

```
import numpy as np

# 예제 배열 생성
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
print("기본 배열:", arr)

# 1. 기본 통계 함수들
print("\n기본 통계:")
print("평균값:", arr.mean())      # 평균
print("합계:", arr.sum())         # 합계
print("최대값:", arr.max())       # 최대값
print("최소값:", arr.min())       # 최소값
print("표준편차:", arr.std())     # 표준편차
print("중앙값:", np.median(arr))  # 중앙값
```

##### 각 통계 함수의 의미:
- mean(): 모든 값의 평균
- sum(): 모든 값의 합계
- max(): 가장 큰 값
- min(): 가장 작은 값
- std(): 표준편차 (데이터의 퍼짐 정도)
- median(): 중앙값 (정렬했을 때 가운데 값)

1. 중앙값 (Median)

```
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
```

- 데이터를 순서대로 나열했을 때 정확히 중앙에 있는 값
- 우리 배열은 10개의 숫자(짝수 개)를 가지고 있음
- 이 경우 중앙의 두 값(5와 6)의 평균을 취함
- 따라서 중앙값 = (5 + 6) / 2 = 5.5

<br>

##### 만약 데이터가 홀수 개라면?

```
arr = np.array([12, 13, 14, 15, 16, 17, 18])  # 7개 (홀수)
# 중앙값 = 15 (가운데 있는 하나의 값)
print("중앙값:", np.median(arr))  # 15
```

- 중앙에 있는 값이 하나라 계산 안 해도 됨.

<br>

2. 표준편차 (Standard Deviation)

**표준편차 계산 과정을 단계별로 설명**

```
arr2 = np.array([0, 1, 2, 3, 4])

# 1단계: 평균 구하기
평균 = 2.0  # (0 + 1 + 2 + 3 + 4) / 5 = 2

# 2단계: 각 값에서 평균을 뺀 후 제곱
(0 - 2)² = (-2)² = 4
(1 - 2)² = (-1)² = 1
(2 - 2)² = 0² = 0
(3 - 2)² = 1² = 1
(4 - 2)² = 2² = 4

# 3단계: 제곱한 값들의 평균
(4 + 1 + 0 + 1 + 4) / 5 = 2

# 4단계: 제곱근(근을 제곱하면 원래 값이 나옴)
√2 ≈ 1.4142135623730951
 └▶ 1.4142135623730951 ** 2 =2
```

- 표준편차는 데이터가 얼마나 퍼져 있는지를 나타냄
- 표준편차가 작으면 데이터가 모여 있고, 크면 데이터가 퍼져 있음
- 표준편차가 0이면 모든 데이터가 같은 값을 가짐

<br><br>

##### 제곱근과 제곱의 관계

```
num = 2
sqrt_num = np.sqrt(2)    # 2의 제곱근 (약 1.4142...)
squared = sqrt_num ** 2  # 1.4142...를 제곱

print(f"2의 제곱근: {sqrt_num}")
print(f"그 제곱근을 다시 제곱하면: {squared}")  # 2가 나옴
```

<br><br>

### 3.배열의 형태 변경(reshape)

```
import numpy as np

# 1차원 배열 생성
arr = np.array([1, 2, 3, 4, 5, 6])
print("1차원 배열:", arr)
print("형태:", arr.shape)  # (6,) -> 6개의 원소를 가진 1차원

# 2차원으로 변경 (2행 3열)
arr_2d = arr.reshape(2, 3)
print("\n2차원 배열 (2행 3열):\n", arr_2d)
print("형태:", arr_2d.shape)  # (2, 3) -> 2행 3열

# 3행 2열로 변경
arr_2d_2 = arr.reshape(3, 2)
print("\n2차원 배열 (3행 2열):\n", arr_2d_2)
print("형태:", arr_2d_2.shape)  # (3, 2) -> 3행 2열
```

```
1차원 배열: [1 2 3 4 5 6]
형태: (6,)

2차원 배열 (2행 3열):
 [[1 2 3]
 [4 5 6]]
형태: (2, 3)

2차원 배열 (3행 2열):
 [[1 2]
 [3 4]
 [5 6]]
형태: (3, 2)
```

**주의할 점**

- 원소의 총 개수는 변하지 않음 (6개)
- 새로운 형태의 크기가 원소 개수와 맞아야 함
- 행 × 열 = 전체 원소 개수

<br><br>

#### 4.배열의 인덱싱(특정 위치의 데이터 선택)

```
import numpy as np

# 2차원 배열 생성
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

print("전체 배열:\n", arr)

# 1. 단일 원소 선택 [행, 열]
print("\n특정 위치의 원소:")
print("1행 2열의 원소:", arr[0, 1])  # 2
print("2행 3열의 원소:", arr[1, 2])  # 6

# 2. 행 전체 선택
print("\n행 전체:")
print("1번째 행:", arr[0])  # [1, 2, 3]
print("2번째 행:", arr[1])  # [4, 5, 6]

# 3. 열 전체 선택
print("\n열 전체:")
print("2번째 열:", arr[:, 1])  # [2, 5, 8]
```

```
전체 배열:
 [[1 2 3]
 [4 5 6]
 [7 8 9]]

특정 위치의 원소:
1행 2열의 원소: 2
2행 3열의 원소: 6

행 전체:
1번째 행: [1 2 3]
2번째 행: [4 5 6]

열 전체:
2번째 열: [2 5 8]
```

***주요 포인트:***

- 인덱스는 0부터 시작
- [행, 열] 순서로 접근
- ' : '콜론은 '전체'를 의미

---

### NumPy에서 배운 핵심 내용 정리:
- 배열 생성과 기본 연산
- 통계 함수 (mean, std, median 등)
- 배열 형태 변경 (reshape)
- 배열 인덱싱

---

***다음 단계인 Pandas에서는:***
- 데이터 읽기
- 결측치 처리
- 기본 통계량
- 데이터 시각화

<br>

***Pandas 주요 기능:***

```
  # 데이터 읽기
   import pandas as pd
   df = pd.read_csv('파일명.csv')

   # 결측치 처리
   df.isnull().sum()  # 결측치 확인
   df.dropna()        # 결측치 제거
   df.fillna()        # 결측치 채우기

   # 기본 통계량
   df.describe()      # 기술 통계
   df.info()          # 데이터 정보

   # 데이터 시각화
   import matplotlib.pyplot as plt
   plt.plot(df['열 이름'])  # 그래프 그리기
   plt.show()                # 그래프 표시
```

이 4가지를 학습해야겠다.
